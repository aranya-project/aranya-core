use std::collections::{HashMap, HashSet};

use aranya_policy_ast::{FieldDefinition, Identifier, Persistence, TypeKind, VType};
use aranya_policy_compiler::PolicyInterface;
use aranya_policy_module::ConstValue;
use proc_macro2::{Span, TokenStream};
use quote::quote;

/// Generate rust source code from a [`PolicyInterface`].
#[allow(clippy::panic)]
pub fn generate_code(target: &PolicyInterface) -> String {
    let reachable = collect_reachable_types(target);

    let constants = target.globals.iter().filter_map(|(id, value)| {
        let ty = constant_value_to_type(value)?;
        let lit = constant_value_to_literal(value);
        let doc = format!(" {id} constant.");
        let name = mk_ident(id);
        Some(quote! {
            #[doc = #doc]
            pub const #name: #ty = #lit;
        })
    });

    let structs = target
        .struct_defs
        .iter()
        .filter(|(id, _fields)| reachable.contains(id.as_str()))
        .map(|(id, fields)| {
            let doc = format!(" {} policy struct.", id);
            let name = mk_ident(id);
            let names = fields.iter().map(|f| mk_ident(&f.identifier.name));
            let types = fields.iter().map(|f| vtype_to_rtype(&f.field_type));
            quote! {
                #[doc = #doc]
                #[value]
                pub struct #name {
                    #(pub #names: #types),*
                }
            }
        });

    let enums = target
        .enum_defs
        .iter()
        .filter(|(id, _values)| reachable.contains(id.as_str()))
        .map(|(id, values)| {
            let doc = format!(" {} policy enum.", id);
            let name = mk_ident(id);
            let names = values.iter().map(|(id, _)| mk_ident(id));
            quote! {
                #[doc = #doc]
                #[value]
                pub enum #name {
                    #(#names),*
                }
            }
        });

    let effects = target.effects.iter().map(|s| {
        let fields = target
            .struct_defs
            .get(s)
            .unwrap_or_else(|| panic!("Effect not defined: {s}"));
        let doc = format!(" {} policy effect.", s);
        let ident = mk_ident(s);
        let field_idents = fields.iter().map(|f| mk_ident(&f.identifier.name));
        let field_types = fields.iter().map(|f| vtype_to_rtype(&f.field_type));
        quote! {
            #[doc = #doc]
            #[effect]
            pub struct #ident {
                #(pub #field_idents: #field_types),*
            }
        }
    });

    let effect_enum = {
        let idents = target.effects.iter().map(mk_ident);
        quote! {
            #[effects]
            pub enum Effect {
                #(
                    #idents(#idents)
                ),*
            }
        }
    };

    let persistent = syn::Ident::new("Persistent", Span::call_site());
    let ephemeral = syn::Ident::new("Ephemeral", Span::call_site());

    let actions = {
        let mut persistent_actions = Vec::new();
        let mut ephemeral_actions = Vec::new();
        let structs = target
            .action_defs
            .iter()
            .map(|def| {
                match def.persistence {
                    Persistence::Persistent => {
                        persistent_actions.push(mk_ident(def.name.as_str()));
                    }
                    Persistence::Ephemeral(_) => {
                        ephemeral_actions.push(mk_ident(def.name.as_str()));
                    }
                }
                let interface = match def.persistence {
                    Persistence::Persistent => &persistent,
                    Persistence::Ephemeral(_) => &ephemeral,
                };
                let doc = format!(" {} policy action.", def.name);
                let ident = mk_ident(def.name.as_str());
                let argnames = def.params.iter().map(|arg| mk_ident(arg.name.as_str()));
                let argtypes = def.params.iter().map(|arg| vtype_to_rtype(&arg.ty));
                quote! {
                    #[doc = #doc]
                    #[action(interface = #interface)]
                    pub struct #ident {
                        #(pub #argnames: #argtypes),*
                    }
                }
            })
            .collect::<Vec<_>>();
        quote! {
            #[actions(interface = #persistent)]
            pub enum PersistentAction {
                #( #persistent_actions(#persistent_actions) ),*
            }
            #[actions(interface = #ephemeral)]
            pub enum EphemeralAction {
                #( #ephemeral_actions(#ephemeral_actions) ),*
            }
            #( #structs )*
        }
    };

    prettyplease::unparse(&syn::parse_quote! {
        //! This code is @generated by `policy-ifgen`. DO NOT EDIT.
        #![cfg_attr(rustfmt, rustfmt::skip)]
        #![allow(clippy::duplicated_attributes)]
        #![allow(clippy::enum_variant_names)]
        #![allow(missing_docs)]
        #![allow(non_camel_case_types)]
        #![allow(non_snake_case)]
        #![allow(non_upper_case_globals)]
        #![allow(unused_imports)]

        extern crate alloc;

        use alloc::vec::Vec;

        use aranya_policy_ifgen::{
            macros::{action, actions, effect, effects, value},
            text, BaseId, ClientError, Value, Text,
        };

        #(#constants)*

        #[derive(Debug)]
        pub enum #persistent {}
        #[derive(Debug)]
        pub enum #ephemeral {}

        #(#structs)*
        #(#enums)*

        /// Enum of policy effects that can occur in response to a policy action.
        #effect_enum
        #(#effects)*

        #actions
    })
}

fn vtype_to_rtype(ty: &VType) -> TokenStream {
    use aranya_policy_ast::TypeKind;
    match &ty.kind {
        TypeKind::String => quote! { Text },
        TypeKind::Bytes => quote! { Vec<u8> },
        TypeKind::Int => quote! { i64 },
        TypeKind::Bool => quote! { bool },
        TypeKind::Id => quote! { BaseId },
        TypeKind::Struct(st) => {
            let ident = mk_ident(&st.name);
            quote! { #ident }
        }
        TypeKind::Enum(st) => {
            let ident = mk_ident(&st.name);
            quote! { #ident }
        }
        TypeKind::Optional(opt) => {
            let inner = vtype_to_rtype(opt);
            quote! {
                Option<#inner>
            }
        }
        TypeKind::Never => unreachable!("cannot use never type in definitions"),
    }
}

fn constant_value_to_type(value: &ConstValue) -> Option<TokenStream> {
    Some(match value {
        ConstValue::Int(_) => quote!(i64),
        ConstValue::Bool(_) => quote!(bool),
        ConstValue::String(_) => quote!(Text),
        ConstValue::Struct(st) => {
            let ident = mk_ident(&st.name);
            quote!(#ident)
        }
        ConstValue::Enum(ident, _) => {
            let ident = mk_ident(ident);
            quote!(#ident)
        }
        ConstValue::Option(Some(value)) => {
            let ty = constant_value_to_type(value)?;
            quote!(Option<#ty>)
        }
        // `Option<!>` would probably work if/when `never_type` stabilizes.
        // Any other choice would give us a type that probably isn't very
        // useful since we can't just coerce it to some other `Option<T>`.
        ConstValue::Option(None) => return None,
    })
}

fn constant_value_to_literal(value: &ConstValue) -> TokenStream {
    match value {
        ConstValue::Int(n) => quote!(#n),
        ConstValue::Bool(b) => quote!(#b),
        ConstValue::String(text) => {
            let text = text.as_str();
            quote!(text!(#text))
        }
        ConstValue::Struct(st) => {
            let ident = mk_ident(&st.name);
            let fields = st.fields.iter().map(|(k, v)| {
                let ident = mk_ident(k);
                let lit = constant_value_to_literal(v);
                quote! {
                    #ident: #lit
                }
            });
            quote!(#ident { #(#fields),* })
        }
        ConstValue::Enum(ident, variant) => {
            let ident = mk_ident(ident);
            quote!(#ident::new(#variant).unwrap())
        }
        ConstValue::Option(None) => quote!(None),
        ConstValue::Option(Some(value)) => {
            let lit = constant_value_to_literal(value);
            quote!(Some(#lit))
        }
    }
}

/// Returns the name of all custom types reachable from actions, effects, and globals.
#[allow(clippy::panic)]
fn collect_reachable_types(target: &PolicyInterface) -> HashSet<Identifier> {
    fn visit(
        struct_defs: &HashMap<&str, &[FieldDefinition]>,
        found: &mut HashSet<Identifier>,
        ty: &TypeKind,
    ) {
        match ty {
            TypeKind::Struct(s) => {
                if found.insert(s.name.clone()) {
                    for field in struct_defs[s.as_str()] {
                        visit(struct_defs, found, &field.field_type.kind);
                    }
                }
            }
            TypeKind::Enum(s) => {
                found.insert(s.name.clone());
            }
            TypeKind::Optional(inner) => visit(struct_defs, found, &inner.kind),
            _ => {}
        }
    }

    let struct_defs = target
        .struct_defs
        .iter()
        .map(|(id, fields)| (id.as_str(), fields.as_slice()))
        .collect::<HashMap<_, _>>();

    let mut found = HashSet::new();

    for def in target.action_defs.iter() {
        for param in def.params.iter() {
            visit(&struct_defs, &mut found, &param.ty.kind);
        }
    }

    for id in &target.effects {
        let fields = target
            .struct_defs
            .get(id)
            .unwrap_or_else(|| panic!("Effect not defined: {id}"));
        for field in fields {
            visit(&struct_defs, &mut found, &field.field_type.kind);
        }
    }

    for value in target.globals.values() {
        if let Some(ty) = value.vtype() {
            visit(&struct_defs, &mut found, &ty);
        }
    }

    found
}

/// Makes an identifier from a string, using raw identifiers (`r#mod`) when necessary.
fn mk_ident(string: impl AsRef<str>) -> syn::Ident {
    let string = string.as_ref();
    syn::parse_str::<syn::Ident>(string)
        .unwrap_or_else(|_| syn::Ident::new_raw(string, Span::call_site()))
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_mk_ident() {
        assert_eq!(mk_ident("foo").to_string(), "foo");
        assert_eq!(mk_ident("mod").to_string(), "r#mod");
    }
}
