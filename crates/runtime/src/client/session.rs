//! Ephemeral sessions for off-graph commands.
//!
//! See [`ClientState::session`] and [`Session`].
//!
//! Design discussion/docs: <https://git.spideroak-inc.com/spideroak-inc/flow3-docs/pull/53>

use alloc::{boxed::Box, collections::BTreeMap, string::String, vec::Vec};
use core::{cmp::Ordering, iter::Peekable, marker::PhantomData, ops::Bound};

use buggy::{bug, Bug, BugExt};
use serde::{Deserialize, Serialize};

use crate::{
    Checkpoint, ClientError, ClientState, Command, CommandId, CommandRecall, Engine, Fact,
    FactPerspective, GraphId, Keys, NullSink, Perspective, Policy, PolicyId, Prior, Priority,
    Query, QueryMut, Revertable, Segment, Sink, Storage, StorageError, StorageProvider,
    MAX_COMMAND_LENGTH,
};

type Bytes = Box<[u8]>;

/// Ephemeral session used to handle/generate off-graph commands.
pub struct Session<SP: StorageProvider, E> {
    /// The ID of the associated storage.
    storage_id: GraphId,
    /// The policy ID for the session.
    policy_id: PolicyId,

    /// Head of the session.
    head_id: CommandId,

    /// The prior facts from the graph head.
    base_facts: <SP::Storage as Storage>::FactIndex,
    /// The log of facts in insertion order.
    fact_log: Vec<(String, Keys, Option<Bytes>)>,
    /// The current facts of the session, relative to `base_facts`.
    current_facts: BTreeMap<String, BTreeMap<Keys, Option<Bytes>>>,

    /// Tag for associated engine.
    _engine: PhantomData<E>,
}

struct SessionPerspective<'a, SP: StorageProvider, E, MS> {
    session: &'a mut Session<SP, E>,
    message_sink: &'a mut MS,
}

impl<SP: StorageProvider, E> Session<SP, E> {
    pub(super) fn new(provider: &mut SP, storage_id: GraphId) -> Result<Self, ClientError> {
        let storage = provider.get_storage(&storage_id)?;
        let head_loc = storage.get_head()?;
        let seg = storage.get_segment(head_loc)?;
        let base_facts = seg.facts()?;

        let result = Self {
            storage_id,
            policy_id: seg.policy(),
            head_id: seg.head().id(),
            base_facts,
            fact_log: Vec::new(),
            current_facts: BTreeMap::new(),
            _engine: PhantomData,
        };

        Ok(result)
    }
}

impl<SP: StorageProvider, E: Engine> Session<SP, E> {
    /// Evaluate an action on the ephemeral session and generate serialized
    /// commands, so another client can [`Session::receive`] them.
    pub fn action<ES, MS>(
        &mut self,
        client: &ClientState<E, SP>,
        effect_sink: &mut ES,
        message_sink: &mut MS,
        action: <E::Policy as Policy>::Action<'_>,
    ) -> Result<(), ClientError>
    where
        ES: Sink<E::Effect>,
        MS: for<'b> Sink<&'b [u8]>,
    {
        let policy = client.engine.get_policy(&self.policy_id)?;

        // Use a special perspective so we can send to the message sink.
        let mut perspective = SessionPerspective {
            message_sink,
            session: self,
        };
        let checkpoint = perspective.checkpoint();
        effect_sink.begin();

        // Try to perform action.
        match policy.call_action(action, &mut perspective, effect_sink) {
            Ok(_) => {
                // Success, commit effects
                effect_sink.commit();
                Ok(())
            }
            Err(e) => {
                // Other error, revert all? See #513.
                perspective.revert(checkpoint);
                perspective.message_sink.rollback();
                effect_sink.rollback();
                Err(e.into())
            }
        }
    }

    /// Handle a command from another client generated by [`Session::action`].
    ///
    /// You do NOT need to reprocess the commands from actions generated in the
    /// same session.
    pub fn receive(
        &mut self,
        client: &ClientState<E, SP>,
        sink: &mut impl Sink<E::Effect>,
        command_bytes: &[u8],
    ) -> Result<(), ClientError> {
        let command: SessionCommand<'_> =
            postcard::from_bytes(command_bytes).map_err(ClientError::SessionDeserialize)?;

        if command.storage_id != self.storage_id {
            bug!("ephemeral commands must be run on the same graph");
        }

        let policy = client.engine.get_policy(&self.policy_id)?;

        // Use a special perspective which doesn't check the head
        let mut perspective = SessionPerspective {
            message_sink: &mut NullSink,
            session: self,
        };

        // Try to evaluate command.
        sink.begin();
        let checkpoint = perspective.checkpoint();
        if let Err(e) = policy.call_rule(&command, &mut perspective, sink, CommandRecall::None) {
            perspective.revert(checkpoint);
            sink.rollback();
            return Err(e.into());
        }
        self.head_id = command.id();
        sink.commit();

        Ok(())
    }
}

#[derive(Serialize, Deserialize)]
/// Used for serializing session commands
struct SessionCommand<'a> {
    storage_id: GraphId,
    priority: u32, // Priority::Basic
    id: CommandId,
    parent: CommandId, // Prior::Single
    #[serde(borrow)]
    data: &'a [u8],
}

impl<'sc> Command for SessionCommand<'sc> {
    fn priority(&self) -> Priority {
        Priority::Basic(self.priority)
    }

    fn id(&self) -> CommandId {
        self.id
    }

    fn parent(&self) -> Prior<CommandId> {
        Prior::Single(self.parent)
    }

    fn policy(&self) -> Option<&[u8]> {
        // Session commands should never have policy?
        None
    }

    fn bytes(&self) -> &[u8] {
        self.data
    }
}

impl<'sc> SessionCommand<'sc> {
    fn from_cmd(storage_id: GraphId, command: &'sc impl Command) -> Result<Self, Bug> {
        if command.policy().is_some() {
            bug!("session command should have no policy")
        }
        Ok(SessionCommand {
            storage_id,
            priority: match command.priority() {
                Priority::Basic(p) => p,
                _ => bug!("wrong command type"),
            },
            id: command.id(),
            parent: match command.parent() {
                Prior::Single(p) => p,
                _ => bug!("wrong command type"),
            },
            data: command.bytes(),
        })
    }
}

/// Query iterator for SessionPerspective which wraps an inner query iterator
struct QueryIterator<I1: Iterator, I2: Iterator> {
    prior: Peekable<I1>,
    current: Peekable<I2>,
}

impl<'q, I1, I2> QueryIterator<I1, I2>
where
    I1: Iterator<Item = Result<Fact, StorageError>>,
    I2: Iterator<Item = (&'q [Box<[u8]>], Option<&'q [u8]>)>,
{
    fn new(prior: I1, current: I2) -> Self {
        Self {
            prior: prior.peekable(),
            current: current.peekable(),
        }
    }
}

impl<'q, I1, I2> Iterator for QueryIterator<I1, I2>
where
    I1: Iterator<Item = Result<Fact, StorageError>>,
    I2: Iterator<Item = (&'q [Box<[u8]>], Option<&'q [u8]>)>,
{
    type Item = Result<Fact, StorageError>;

    fn next(&mut self) -> Option<Self::Item> {
        // We find the next lowest item between the two iterators,
        // while also ensuring that newer entries overwrite older.
        // We loop so we can skip over deleted facts.

        loop {
            let Some(new) = self.current.peek() else {
                // If current has run out, just use prior.
                return self.prior.next();
            };
            if let Some(old) = self.prior.peek() {
                let Ok(old) = old else {
                    // Bubble up errors as soon as possible, instead of returning `new`.
                    return self.prior.next();
                };
                match new.0.cmp(old.key.as_ref()) {
                    Ordering::Equal => {
                        // new overwrites old.
                        let _ = self.prior.next();
                    }
                    Ordering::Greater => {
                        // old comes next in sorted order.
                        return self.prior.next();
                    }
                    Ordering::Less => {
                        // new comes next in sorted order.
                    }
                }
            }
            let Some(slot) = self.current.next() else {
                bug!("expected Some after peek")
            };
            if let (k, Some(v)) = slot {
                return Some(Ok(Fact {
                    key: k.iter().cloned().collect(),
                    value: v.into(),
                }));
            }
        }
    }
}

impl<'a, SP, E, MS> FactPerspective for SessionPerspective<'a, SP, E, MS> where SP: StorageProvider {}

impl<'a, SP, E, MS> Query for SessionPerspective<'a, SP, E, MS>
where
    SP: StorageProvider,
{
    fn query(&self, name: &str, keys: &[Box<[u8]>]) -> Result<Option<Box<[u8]>>, StorageError> {
        if let Some(slot) = self
            .session
            .current_facts
            .get(name)
            .and_then(|m| m.get(keys))
        {
            return Ok(slot.clone());
        }
        self.session.base_facts.query(name, keys)
    }

    type QueryIterator<'q> = QueryIterator<
        <<SP::Storage as Storage>::FactIndex as Query>::QueryIterator<'q>,
        Box<dyn Iterator<Item = (&'q [Box<[u8]>], Option<&'q [u8]>)> + 'q>,
    > where Self: 'q;
    fn query_prefix(
        &self,
        name: &str,
        prefix: &[Box<[u8]>],
    ) -> Result<Self::QueryIterator<'_>, StorageError> {
        let prior = self.session.base_facts.query_prefix(name, prefix)?;
        let current: Box<dyn Iterator<Item = _>> =
            self.session
                .current_facts
                .get(name)
                .map_or(Box::new(core::iter::empty()), |facts| {
                    Box::new(
                        facts
                            .range::<[Box<[u8]>], _>((Bound::Included(prefix), Bound::Unbounded))
                            .take_while({
                                let prefix: Keys = prefix.iter().cloned().collect();
                                move |(k, _)| k.starts_with(&prefix)
                            })
                            .map(|(k, v)| (k.as_ref(), v.as_deref())),
                    )
                });
        Ok(QueryIterator::new(prior, current))
    }
}

impl<'a, SP: StorageProvider, E, MS> QueryMut for SessionPerspective<'a, SP, E, MS> {
    fn insert(&mut self, name: String, keys: Keys, value: Box<[u8]>) {
        self.session
            .fact_log
            .push((name.clone(), keys.clone(), Some(value.clone())));
        self.session
            .current_facts
            .entry(name)
            .or_default()
            .insert(keys, Some(value));
    }

    fn delete(&mut self, name: String, keys: Keys) {
        self.session
            .fact_log
            .push((name.clone(), keys.clone(), None));
        self.session
            .current_facts
            .entry(name)
            .or_default()
            .insert(keys, None);
    }
}

impl<'a, SP, E, MS> Perspective for SessionPerspective<'a, SP, E, MS>
where
    SP: StorageProvider,
    MS: for<'b> Sink<&'b [u8]>,
{
    fn policy(&self) -> PolicyId {
        self.session.policy_id
    }

    fn add_command(&mut self, command: &impl Command) -> Result<usize, StorageError> {
        let command = SessionCommand::from_cmd(self.session.storage_id, command)?;
        let mut buf = [0u8; MAX_COMMAND_LENGTH];
        let bytes = postcard::to_slice(&command, &mut buf).assume("can serialize")?;
        self.message_sink.consume(bytes);

        Ok(0)
    }

    fn includes(&self, _id: &CommandId) -> bool {
        debug_assert!(false, "only used in transactions");

        false
    }

    fn head_id(&self) -> Prior<CommandId> {
        Prior::Single(self.session.head_id)
    }
}

impl<'a, SP, E, MS> Revertable for SessionPerspective<'a, SP, E, MS>
where
    SP: StorageProvider,
{
    fn checkpoint(&self) -> Checkpoint {
        Checkpoint {
            index: self.session.fact_log.len(),
        }
    }

    fn revert(&mut self, checkpoint: Checkpoint) {
        if checkpoint.index >= self.session.fact_log.len() {
            return;
        }
        self.session.fact_log.truncate(checkpoint.index);
        self.session.current_facts.clear();
        for (n, k, v) in self.session.fact_log.iter().cloned() {
            self.session
                .current_facts
                .entry(n)
                .or_default()
                .insert(k, v);
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_query_iterator() {
        #![allow(clippy::type_complexity)]

        let prior: Vec<Result<(&[&[u8]], &[u8]), _>> = vec![
            Ok((&[b"a"], b"a0")),
            Ok((&[b"c"], b"c0")),
            Ok((&[b"d"], b"d0")),
            Ok((&[b"f"], b"f0")),
            Err(StorageError::IoError),
        ];
        let current: Vec<([Box<[u8]>; 1], Option<&[u8]>)> = vec![
            ([Box::new(*b"a")], None),
            ([Box::new(*b"b")], Some(b"b1")),
            ([Box::new(*b"e")], None),
            ([Box::new(*b"j")], None),
        ];
        let merged: Vec<Result<(&[&[u8]], &[u8]), _>> = vec![
            Ok((&[b"b"], b"b1")),
            Ok((&[b"c"], b"c0")),
            Ok((&[b"d"], b"d0")),
            Ok((&[b"f"], b"f0")),
            Err(StorageError::IoError),
        ];

        let got: Vec<_> = QueryIterator::new(
            prior.into_iter().map(|r| {
                r.map(|(k, v)| Fact {
                    key: k.into(),
                    value: v.into(),
                })
            }),
            current.iter().map(|(k, v)| (k.as_slice(), *v)),
        )
        .collect();
        let want: Vec<_> = merged
            .into_iter()
            .map(|r| {
                r.map(|(k, v)| Fact {
                    key: k.into(),
                    value: v.into(),
                })
            })
            .collect();

        assert_eq!(got, want);
    }
}
