//! Test utilities for the IR module.

#[cfg(test)]
pub mod test_utils {
    use aranya_policy_ast::Identifier;
    use aranya_policy_lang::lang::{parse_policy_str, Version};
    use aranya_policy_module::{Instruction as BytecodeInstruction, Module, ModuleData, Target};
    use crate::ir::{IRBuilder, IR};
    use crate::ir::error::IRBuildError;
    use crate::Compiler;
    use std::collections::HashMap;
    
    /// Build IR from policy source code.
    pub fn build_ir_from_source(source: &str) -> Result<IR, Vec<IRBuildError>> {
        let ast = parse_policy_str(source, Version::V2)
            .map_err(|e| vec![IRBuildError::ParseError(format!("{:?}", e))])?;
        IRBuilder::build_from_ast(&ast)
    }
    
    /// Assert that two bytecode sequences are semantically equivalent.
    /// This handles differences in labels, metadata, etc.
    pub fn assert_bytecode_equivalent(
        actual: &[BytecodeInstruction],
        expected: &[BytecodeInstruction]
    ) {
        let actual_normalized = normalize_bytecode(actual);
        let expected_normalized = normalize_bytecode(expected);
        
        if actual_normalized != expected_normalized {
            panic!(
                "Bytecode mismatch:\nActual:\n{}\n\nExpected:\n{}\n",
                format_bytecode(&actual_normalized),
                format_bytecode(&expected_normalized)
            );
        }
    }
    
    /// Assert that IR-generated bytecode matches compiler-generated bytecode for a function.
    pub fn assert_compiler_bytecode_equivalent(
        ir_bytecode: &[BytecodeInstruction],
        module: &Module,
        function_name: &str
    ) {
        let compiler_bytecode = extract_function_bytecode(module, function_name)
            .expect(&format!("Function '{}' not found in module", function_name));
        
        let ir_normalized = normalize_bytecode(ir_bytecode);
        let compiler_normalized = normalize_bytecode(&compiler_bytecode);
        
        if ir_normalized != compiler_normalized {
            panic!(
                "Bytecode mismatch for function '{}':\nIR:\n{}\n\nCompiler:\n{}\n",
                function_name,
                format_bytecode(&ir_normalized),
                format_bytecode(&compiler_normalized)
            );
        }
    }
    
    /// Extract bytecode for a specific function from a compiled module.
    pub fn extract_function_bytecode(module: &Module, function_name: &str) -> Option<Vec<BytecodeInstruction>> {
        let module_v0 = match &module.data {
            ModuleData::V0(v0) => v0,
        };
        
        let func_ident = Identifier::try_from(function_name.to_string()).ok()?;
        
        // Find the function label
        let func_label = module_v0.labels.iter()
            .find(|(label, _)| label.name == func_ident)
            .map(|(label, _)| label)?;
        
        // Find the start address
        let start_addr = *module_v0.labels.get(func_label)?;
        
        // Find the end address (next label or end of program)
        let sorted_labels: Vec<_> = module_v0.labels.iter()
            .map(|(_, addr)| *addr)
            .collect();
        let mut sorted_addrs = sorted_labels;
        sorted_addrs.sort();
        
        let end_addr = sorted_addrs.iter()
            .find(|&&addr| addr > start_addr)
            .copied()
            .unwrap_or(module_v0.progmem.len());
        
        // Extract instructions
        Some(module_v0.progmem[start_addr..end_addr].to_vec())
    }
    
    /// Normalize bytecode for comparison.
    /// This removes or normalizes elements that may differ between implementations
    /// but don't affect semantics.
    fn normalize_bytecode(bytecode: &[BytecodeInstruction]) -> Vec<BytecodeInstruction> {
        let mut normalized = Vec::new();
        let mut label_map = HashMap::new();
        let mut next_label_id = 0;
        
        // First pass: collect labels and create mapping
        for (i, instr) in bytecode.iter().enumerate() {
            match instr {
                BytecodeInstruction::Meta(aranya_policy_module::Meta::Let(name)) => {
                    label_map.insert(name.clone(), next_label_id);
                    next_label_id += 1;
                }
                BytecodeInstruction::Jump(Target::Unresolved(label)) |
                BytecodeInstruction::Branch(Target::Unresolved(label)) |
                BytecodeInstruction::Call(Target::Unresolved(label)) => {
                    if !label_map.contains_key(&label.name) {
                        label_map.insert(label.name.clone(), next_label_id);
                        next_label_id += 1;
                    }
                }
                _ => {}
            }
        }
        
        // Second pass: normalize instructions
        for instr in bytecode {
            match instr {
                // Skip certain metadata that doesn't affect semantics
                BytecodeInstruction::Meta(aranya_policy_module::Meta::FFI(_, _)) => {
                    // Skip FFI metadata in normalization
                }
                
                // Normalize labels
                BytecodeInstruction::Meta(aranya_policy_module::Meta::Let(name)) => {
                    // Skip label definitions in normalized output
                    // We'll handle jumps by normalizing targets
                }
                
                // Normalize jump targets
                BytecodeInstruction::Jump(target) => {
                    normalized.push(BytecodeInstruction::Jump(normalize_target(target, &label_map)));
                }
                BytecodeInstruction::Branch(target) => {
                    normalized.push(BytecodeInstruction::Branch(normalize_target(target, &label_map)));
                }
                BytecodeInstruction::Call(target) => {
                    normalized.push(BytecodeInstruction::Call(normalize_target(target, &label_map)));
                }
                
                // Keep other instructions as-is
                _ => normalized.push(instr.clone()),
            }
        }
        
        normalized
    }
    
    /// Normalize a jump target.
    fn normalize_target(target: &Target, label_map: &HashMap<Identifier, usize>) -> Target {
        match target {
            Target::Unresolved(label) => {
                if let Some(&id) = label_map.get(&label.name) {
                    Target::Resolved(id)
                } else {
                    // Keep unresolved if not in map (e.g., external functions)
                    target.clone()
                }
            }
            Target::Resolved(addr) => Target::Resolved(*addr),
        }
    }
    
    /// Format bytecode for display in error messages.
    fn format_bytecode(bytecode: &[BytecodeInstruction]) -> String {
        bytecode.iter()
            .enumerate()
            .map(|(i, instr)| format!("{:4}: {:?}", i, instr))
            .collect::<Vec<_>>()
            .join("\n")
    }
    
    /// Compile source code using the regular compiler.
    pub fn compile_with_compiler(source: &str) -> Result<Module, String> {
        let ast = parse_policy_str(source, Version::V2)
            .map_err(|e| format!("Parse error: {:?}", e))?;
        
        Compiler::new(&ast)
            .compile()
            .map_err(|e| format!("Compile error: {:?}", e))
    }
}