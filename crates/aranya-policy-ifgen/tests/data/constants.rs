//! This code is @generated by `policy-ifgen`. DO NOT EDIT.
#![cfg_attr(rustfmt, rustfmt::skip)]
#![allow(clippy::duplicated_attributes)]
#![allow(clippy::enum_variant_names)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]
extern crate alloc;
use alloc::vec::Vec;
use aranya_policy_ifgen::{
    macros::{action, actions, effect, effects, value},
    text, BaseId, ClientError, Value, Text,
};
/// g_bool constant.
pub const g_bool: bool = true;
/// g_enum constant.
pub const g_enum: Answer = Answer::new(1i64).unwrap();
/// g_int constant.
pub const g_int: i64 = 42i64;
/// g_none constant.
pub const g_none: Option<()> = None;
/// g_some constant.
pub const g_some: Option<i64> = Some(42i64);
/// g_string constant.
pub const g_string: Text = text!("a\n\u{1}b");
/// g_struct constant.
pub const g_struct: Complex = Complex {
    m_bool: false,
    m_enum: Answer::new(0i64).unwrap(),
    m_int: 1i64,
    m_none: None,
    m_some: Some(2i64),
    m_string: text!("hello"),
    m_struct: Simple { m_int: 3i64 },
};
#[derive(Debug)]
pub enum Persistent {}
#[derive(Debug)]
pub enum Ephemeral {}
/// Complex policy struct.
#[value]
pub struct Complex {
    pub m_int: i64,
    pub m_bool: bool,
    pub m_string: Text,
    pub m_some: Option<i64>,
    pub m_none: Option<i64>,
    pub m_enum: Answer,
    pub m_struct: Simple,
}
/// Simple policy struct.
#[value]
pub struct Simple {
    pub m_int: i64,
}
/// Answer policy enum.
#[value]
pub enum Answer {
    Yes,
    No,
}
/// Enum of policy effects that can occur in response to a policy action.
#[effects]
pub enum Effect {}
#[actions(interface = Persistent)]
pub enum PersistentAction {}
#[actions(interface = Ephemeral)]
pub enum EphemeralAction {}
