#![cfg_attr(not(doctest), doc = include_str!("../README.md"))]
#![no_std]
#![allow(clippy::needless_doctest_main)]
#![warn(missing_docs)]

extern crate alloc;

use alloc::{collections::BTreeMap, vec::Vec};

/// Macros used in code generated by `policy_ifgen_build``.
pub mod macros {
    pub use aranya_policy_ifgen_macro::{action, actions, effect, effects, value};
}

pub use alloc::format;

pub use aranya_policy_vm::{
    BaseId, Identifier, KVPair, Struct, Text, TryFromValue, Value, ValueConversionError, ident,
};
pub use aranya_runtime::{ClientError, VmAction, VmEffect, vm_action, vm_effect};
#[cfg(feature = "serde")]
pub use serde;

/// Struct fields
pub type Fields = Vec<KVPair>;
/// Map of struct fields
pub type FieldMap = BTreeMap<Identifier, Value>;

/// A type which can be used as a [`VmAction`].
pub trait Actionable {
    /// A type tag used for restricting valid actions for a client.
    type Interface;

    /// Call a function by turning self into a [`VmAction`] and passing it as a parameter.
    fn with_action<R>(self, f: impl for<'a> FnOnce(VmAction<'a>) -> R) -> R;
}

/// Possible errors from policy effect parsing.
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, thiserror::Error)]
pub enum EffectsParseError {
    /// Effect has one or more extra fields.
    #[error("effect has one of more extra fields")]
    ExtraFields,
    /// Effect is missing an expected field.
    #[error("effect is missing an expected field")]
    MissingField,
    /// Effect has unexpected field type.
    #[error("effect has an unexpected field type")]
    FieldTypeMismatch,
    /// Effect has unknown effect name.
    #[error("effect has an unknown effect name")]
    UnknownEffectName,
}

/// The effect did not match the expected variant.
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, thiserror::Error)]
#[error("unexpected effect variant")]
pub struct EffectVariantMismatch<T>(pub T);
