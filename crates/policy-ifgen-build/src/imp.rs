use policy_ast::{Policy, VType};
use proc_macro2::TokenStream;
use quote::{format_ident, quote};

/// Generate rust source code from a [`Policy`] AST.
pub fn generate_code(policy: &Policy) -> String {
    let structs = policy.structs.iter().map(|s| {
        structify(
            &s.identifier,
            s.fields.iter().map(|f| f.identifier.as_str()),
            s.fields.iter().map(|f| &f.field_type),
        )
    });

    let effects = policy.effects.iter().map(|s| {
        let doc = format!(" {} policy effect.", s.identifier);
        let ident = format_ident!("{}", s.identifier);
        let field_idents = s.fields.iter().map(|f| format_ident!("{}", f.identifier));
        let field_types = s.fields.iter().map(|f| vtype_to_rtype(&f.field_type));
        quote! {
            #[doc = #doc]
            #[effect]
            pub struct #ident {
                #(pub #field_idents: #field_types),*
            }
        }
    });

    let effect_enum = {
        let idents = policy
            .effects
            .iter()
            .map(|s| format_ident!("{}", s.identifier));
        quote! {
            #[effects]
            pub enum Effect {
                #(
                    #idents(#idents)
                ),*
            }
        }
    };

    let actions = {
        let sigs = policy.actions.iter().map(|action| {
            let ident = format_ident!("{}", action.identifier);
            let argnames = action
                .arguments
                .iter()
                .map(|arg| format_ident!("{}", arg.identifier));
            let argtypes = action
                .arguments
                .iter()
                .map(|arg| vtype_to_rtype(&arg.field_type));
            quote! {
                fn #ident(&mut self, #(#argnames: #argtypes),*) -> Result<(), ClientError>;
            }
        });
        quote! {
            /// Implements all supported policy actions.
            #[actions]
            pub trait ActorExt {
                #( #sigs )*
            }
        }
    };

    prettyplease::unparse(&syn::parse_quote! {
        //! Code generated by `policy-ifgen`. DO NOT EDIT.
        #![allow(clippy::enum_variant_names)]
        #![allow(missing_docs)]
        #![allow(non_snake_case)]
        #![allow(unused_imports)]

        extern crate alloc;

        use alloc::{string::String, vec::Vec};

        use policy_ifgen::{
            macros::{actions, effect, effects, value},
            ClientError, Id, Value,
        };

        #(#structs)*

        /// Enum of policy effects that can occur in response to a policy action.
        #effect_enum
        #(#effects)*

        #actions
    })
}

fn vtype_to_rtype(ty: &VType) -> TokenStream {
    match ty {
        VType::String => quote! { String },
        VType::Bytes => quote! { Vec<u8> },
        VType::Int => quote! { i64 },
        VType::Bool => quote! { bool },
        VType::Id => quote! { Id },
        VType::Struct(st) => {
            let ident = format_ident!("{}", st);
            quote! { #ident }
        }
        VType::Optional(opt) => {
            let inner = vtype_to_rtype(opt);
            quote! {
                Option<#inner>
            }
        }
    }
}

fn structify<'a, N, T>(name: &str, names: N, types: T) -> TokenStream
where
    N: IntoIterator<Item = &'a str>,
    T: IntoIterator<Item = &'a VType>,
{
    let doc = format!(" {} policy struct.", name);
    let name = format_ident!("{name}");
    let names = names.into_iter().map(|n| format_ident!("{n}"));
    let types = types.into_iter().map(vtype_to_rtype);
    quote! {
        #[doc = #doc]
        #[value]
        pub struct #name {
            #(pub #names: #types),*
        }
    }
}
